/* nv_form.nvgt - audio form rewrite(with some code taken from the original form)
 *
 * NVGT - NonVisual Gaming Toolkit
 * Copyright (c) 2022-2024 Sam Tupy
 * https://nvgt.gg
 * nv_form - Copyright (C) 2025 Ivan Soto
 * This software is provided "as-is", without any express or implied warranty. In no event will the authors be held liable for any damages arising from the use of this software.
 * Permission is granted to anyone to use this software for any purpose, including commercial applications, and to alter it and redistribute it freely, subject to the following restrictions:
 * 1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
 * 2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
 * 3. This notice may not be removed or altered from any source distribution.
*/
#include"enums.nvgt"
#include"nv_form_funcdefs.nvgt"
#include"speech.nvgt"
#include"controls/*"
class nv_form {
	nv_form_control@[]controls;
	int max_controls = 0;
	int control_index = -1;
	string window_title;
	bool speak_control_attributes_separately = false;
	bool active = false;
	private nv_form_errorcode[] errors;
	nv_form_control@primary_control = null, cancel_control = null;
	nv_form_callback@background_callback = null;
	nv_form() {
		this.reset();
	}
	void reset() {
		this.window_title = "";
		this.active = false;
		this.controls.resize(0);
		@this.primary_control = null;
		@this.cancel_control = null;
	}
	nv_form_control@get_control_by_id(const string&in id) {
		if(this.controls.length()<=0) return null;
		for(uint i = 0; i<this.controls.length(); i+=1) {
			if(this.controls[i].id == id) return this.controls[i];
		}
		return null;
	}
	nv_form_control@get_current_control() const property {
		if(this.controls.length()<=0 or this.control_index < 0) return null;
		return @this.controls[this.control_index];
	}
	nv_form_control@find_next_control(bool next = true) {
		if(this.controls.length() == 0) return null;
		int index = this.control_index;
		while(true) {
			index += (next ? 1 : -1);
			if(index < 0 or index >= this.controls.length())
				index = (index>=this.controls.length()?0:this.controls.length()-1);
			if(@this.controls[index] != null and !this.controls[index].hidden)
				return this.controls[index];
		}
		return null;
	}
	bool create_window(string title, bool change_screen_title = true, bool say_dialog = true, bool silent = false) {
		if(this.active) return this.error(nv_form_error_already_active);
		if(title.empty()) return this.error(nv_form_error_invalid_operation);
		this.window_title = title;
		this.active = true;
		if(change_screen_title) show_window(this.window_title);
		if(!silent) {
			speak(window_title+(say_dialog?" dialog":""), false);
		}
		return true;
	}
	bool check_controls(nv_form_control@&out ctrl = void) {
		if(this.controls.length()<=0) return false;
		bool result = false;
		for(uint i = 0; i<this.controls.length(); i+=1) {
			if(this.controls[i].monitor()) {
				result = true;
				@ctrl = this.controls[i];
				break;
			}
		}
		return result;
	}
	bool monitor() {
		if(!this.active) return false;
		this.handle_input();
		nv_form_control@ctrl;
		bool result = this.check_controls(ctrl);
		if(result and @ctrl != null and (@this.cancel_control != null and @ctrl == this.cancel_control)) return false;
		return true;
	}
	void handle_input() {
		nv_form_control@cur_control = this.current_control;
		if(@cur_control != null) cur_control.handle_input();
		if(@cur_control != null and cur_control.type != nv_form_ct_keyboard_area) {
			if(key_pressed(KEY_SPACE)) {
				nv_form_control@ctrl = this.current_control;
				if(@ctrl != null) ctrl.fire();
			}
			if(key_pressed(KEY_ESCAPE) and @this.cancel_control != null) this.cancel_control.fire();
		}
		if(key_repeating(KEY_TAB)) {
			bool next_control = true;
			if(key_down(KEY_LSHIFT) or key_down(KEY_RSHIFT)) next_control = false;
			this.navigate_form(next_control);
		}
	}
	bool error(nv_form_errorcode error) {
		this.errors.insert_last(error);
		return true;
	}
	nv_form_errorcode get_last_error() const property {
		if(this.errors.length()<=0) return nv_form_error_none;
		return this.errors[this.errors.length()-1];
	}
	//helper functions.
	bool is_pressed(string control_id) {
		nv_form_control@ctrl = this.get_control_by_id(control_id);
		if(@ctrl == null or ctrl.type != nv_form_ct_button) return this.error(nv_form_error_invalid_control);
		nv_form_button@btn = cast<nv_form_button@>(ctrl);
		if(@btn == null) return this.error(nv_form_error_invalid_control);
		return this.is_pressed(btn);
	}
	bool is_pressed(nv_form_button@btn) {
		if(@btn.parent != this) return this.error(nv_form_error_invalid_control);
		bool result = btn.pressed;
		if(result) btn.pressed = false;
		return result;
	}
	bool is_checked(string control_id) {
		nv_form_checkbox@box = cast<nv_form_checkbox@>(this.get_control_by_id(control_id));
		if(@box == null) return this.error(nv_form_error_invalid_control);
		return this.is_checked(box);
	}
	bool is_checked(nv_form_checkbox@box) {
		if(@box.parent != this) return this.error(nv_form_error_invalid_control);
		return box.state;
	}
	nv_form_list_item@get_list_focus(string control_id) {
		return this.get_list_focus(cast<nv_form_list_box@>(this.get_control_by_id(control_id)));
	}
	nv_form_list_item@get_list_focus(nv_form_list_box@lst) {
		if(@lst == null or @lst.parent != this) {
			this.error(nv_form_error_invalid_control);
			return null;
		}
		return lst.focused_item;
	}
	int get_slider_value(string control_id) {
		return this.get_slider_value(cast<nv_form_slider@>(this.get_control_by_id(control_id)));
	}
	int get_slider_value(nv_form_slider@slider) {
		if(@slider == null or @slider.parent != this) {
			this.error(nv_form_error_invalid_control);
			return 0;
		}
		return slider.value;
	}
	nv_form_button@add_button(string caption, string id = "", bool primary = false, bool cancel = false, int position = -1, nv_form_control_callback@callback = null) {
		nv_form_button@btn = nv_form_button(this, caption, id);
		bool added = this.add_control(btn, primary, cancel, position, @callback);
		if(added) return btn;
		return null;
	}
	nv_form_checkbox@add_checkbox(string caption, string id = "", bool selected = false, int position = -1) {
		nv_form_checkbox@checkbox = nv_form_checkbox(this, caption, id, selected);
		bool added = this.add_control(checkbox, position = position);
		if(added) return checkbox;
		return null;
	}
	nv_form_list_box@add_list(string caption, string id = "", bool allow_multiselect = false, nv_form_list_item@[] items = {}, int max_items = 0, int position = -1) {
		nv_form_list_box@lst = nv_form_list_box(this, caption, id, allow_multiselect, items, max_items);
		bool added = this.add_control(lst, position = position);
		if(added) return lst;
		return null;
	}
	nv_form_slider@add_slider(string caption, string id = "", int min_value = 0, int max_value = 100, int step_size = 1, int initial_value = 0, int position = -1) {
		nv_form_slider slide(this, caption, id, min_value, max_value, step_size, initial_value);
		bool added = this.add_control(@slide, position = position);
		if(added) return slide;
		return null;
	}
	nv_form_progress_bar@add_progress_bar(string caption, string id = "", double min = 0, double max = 100, double initial = 0.0, int position = -1) {
		nv_form_progress_bar@bar = nv_form_progress_bar(@this, caption, id, min, max, initial);
		bool added = this.add_control(@bar, position = position);
		if(added) return bar;
		return null;
	}
	nv_form_keyboard_area@add_keyboard_area(string caption, string id = "", int position = -1) {
		nv_form_keyboard_area area(@this, caption, id);
		bool added = this.add_control(@area, position = position);
		if(added) return area;
		return null;
	}
	bool add_control(nv_form_control@ctrl, bool primary = false, bool cancel = false, int position = -1, nv_form_control_callback@callback = null) {
		if(!this.active) return this.error(nv_form_error_no_window);
		if(this.max_controls>0 and this.controls.length()>=this.max_controls) return this.error(nv_form_error_window_full);
		if(@ctrl == null) return this.error(nv_form_error_invalid_control);
		if(@callback != null) @ctrl.callback = callback;
		if(position <0) this.controls.insert_last(ctrl);
		else this.controls.insert_at(position, ctrl);
		if(primary) @this.primary_control = @ctrl;
		if(cancel) @this.cancel_control = @ctrl;
		return true;
	}
	bool navigate_form(bool next = true) {
		nv_form_control@ctrl = this.find_next_control(next);
		return this.focus_control(ctrl);
	}
	bool focus_control(nv_form_control@ctrl, bool quiet = false, bool interupt_previous_speech = true) {
		if(@ctrl == null) return false;
		int index = this.controls.find_by_ref(ctrl);
		if(index == -1) return false;
		return this.set_focus(index, quiet, interupt_previous_speech);
	}
	private bool set_focus(int control_index, bool quiet = false, bool interrupt_previous_speech = true) {
		if(control_index<0 or control_index>=this.controls.length()) return false;
		this.control_index = control_index;
		bool result;
		if(!quiet) result = this.speak_current_control(interrupt_previous_speech);
		else result = true;
		this.current_control.on_focus_gained();
		return result;
	}
	bool speak_current_control(bool interrupt = true) {
		if(this.control_index == -1) return false;
		nv_form_control@ctrl = this.controls[this.control_index];
		if(@ctrl == null) return false;
		string text = ctrl.caption+" "+get_nv_form_control_type_string(ctrl.type);
		if(!this.speak_control_attributes_separately) {
			text += " "+ctrl.get_control_info();
			return speak(text, interrupt);
		}
		else {
			speak(text, interrupt);
			speak(ctrl.get_control_info(), false);
			return true;
		}
	}
}
